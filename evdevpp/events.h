#ifndef EVDEVPP_EVDEVPP_EVENTS_H_
#define EVDEVPP_EVDEVPP_EVENTS_H_

#include <cstdint>
#include <limits>
#include <new>
#include <optional>
#include <utility>

#include "absl/time/time.h"
#include "evdevpp/ecodes.h"
#include "fmt/format.h"

namespace evdevpp {

// This library provides the `InputEvent` class, which mirrors
// the `input_event` struct defined in `linux/input.h`:
//
// struct input_event {
//   struct timeval time;
//   __u16 type;
//   __u16 code;
//   __s32 value;
// };
//
// This module also defines several `InputEvent` sub-classes that
// know more about the different types of events (key, abs, rel, etc).
//
// The `AnyInputEvent` class can be used to store by value a categorized
// event (polymorphic). Categorizing events can be done with the
// `AnyInputEvent::Categorize` function. Note, however, that this could be
// an expensive operation involving hash-map lookups, and it's usually not
// necessary, but can produce nicer string formatting and such.
//
// All classes in this library have reasonable `fmt` formatting capability.

// A generic input event.
struct InputEvent {
  absl::Time timestamp = absl::InfinitePast();
  EventType type{};
  std::uint16_t code = 0;
  std::int32_t value = 0;

  InputEvent() = default;
  InputEvent(absl::Time init_timestamp, EventType init_type,
             std::uint16_t init_code, std::int32_t init_value)
      : timestamp(init_timestamp),
        type(init_type),
        code(init_code),
        value(init_value) {}
  InputEvent(const InputEvent&) = default;
  InputEvent& operator=(const InputEvent&) = default;
  virtual ~InputEvent() = default;

  virtual const char* TypeAsString() const { return type.ToString(); }
  virtual bool IsInCategory() const { return false; };
  virtual const char* CodeAsString() const { return "UNCATEGORIZED"; }

  static constexpr std::uint16_t kUncategorizedCode =
      std::numeric_limits<std::uint16_t>::max();
  // Internal use.
  virtual void CloneInplace(InputEvent* ptr) const {
    new (ptr) InputEvent(*this);
  }
};

// An event generated by a keyboard, button or other key-like devices.
struct KeyEvent : InputEvent {
  enum class State {
    kUp,
    kDown,
    kHold,
  };
  State state = State::kUp;
  Key key = kUncategorizedCode;
  Button button = kUncategorizedCode;

  template <typename... Args>
  explicit KeyEvent(Args&&... args) : InputEvent(std::forward<Args>(args)...) {
    switch (value) {
      case 1:
        state = State::kDown;
        break;
      case 2:
        state = State::kHold;
        break;
      default:
        state = State::kUp;
        break;
    }
    const auto& keys = Key::CodeToString();
    if (keys.find(code) != keys.end()) {
      key = code;
    }
    const auto& buttons = Button::CodeToString();
    if (buttons.find(code) != buttons.end()) {
      button = code;
    }
  }

  bool IsKey() const { return (key != kUncategorizedCode); }
  bool IsButton() const { return (button != kUncategorizedCode); }
  bool IsInCategory() const override { return IsKey() || IsButton(); }

  const char* TypeAsString() const override { return Key::kClassName; }
  const char* CodeAsString() const override {
    if (IsKey()) {
      return key.ToString();
    }
    if (IsButton()) {
      return button.ToString();
    }
    return "UNKNOWN";
  }
  // For internal use.
  using ExpectedECodeType = Key;
  void CloneInplace(InputEvent* ptr) const override {
    new (ptr) KeyEvent(*this);
  }
};

template <typename ECodeType>
struct CategorizedEvent : InputEvent {
  ECodeType categorized = kUncategorizedCode;

  template <typename... Args>
  explicit CategorizedEvent(Args&&... args)
      : InputEvent(std::forward<Args>(args)...) {
    const auto& codes = ECodeType::CodeToString();
    if (codes.find(code) != codes.end()) {
      categorized = code;
    }
  }

  bool IsInCategory() const override {
    return (categorized != kUncategorizedCode);
  }

  const char* TypeAsString() const override { return ECodeType::kClassName; }
  const char* CodeAsString() const override { return categorized.ToString(); }
  // For internal use.
  using ExpectedECodeType = ECodeType;
  void CloneInplace(InputEvent* ptr) const override {
    new (ptr) CategorizedEvent<ECodeType>(*this);
  }
};

// A relative axis event (e.g moving the mouse 5 units to the left).
using RelEvent = CategorizedEvent<RelativeAxis>;

// A absolute axis event (e.g moving the mouse 5 units to the left).
using AbsEvent = CategorizedEvent<AbsoluteAxis>;

// A synchronization event. Used as markers to separate events. Events may be
// separated in time or in space, such as with the multitouch protocol.
using SynchEvent = CategorizedEvent<Synch>;

// A switch event (e.g., plugging in headphones).
using SwitchEvent = CategorizedEvent<Switch>;

// A miscellaneous event (e.g., gesture).
using MiscEvent = CategorizedEvent<Misc>;

// An LED event (e.g., caps-lock).
using LEDEvent = CategorizedEvent<LED>;

// An auto-repeat event (e.g., pulsing).
using AutorepeatEvent = CategorizedEvent<Autorepeat>;

// A sound event (e.g., click).
using SoundEvent = CategorizedEvent<Sound>;

class AnyInputEvent {
 public:
  explicit AnyInputEvent(const InputEvent& rhs) : data_{.base = rhs} {
    data_.base.~InputEvent();
    rhs.CloneInplace(&data_.base);
  }
  AnyInputEvent() : AnyInputEvent(InputEvent{}) {}
  AnyInputEvent(const AnyInputEvent& rhs) : AnyInputEvent(rhs.data_.base) {}

  AnyInputEvent& operator=(const AnyInputEvent& rhs) {
    data_.base.~InputEvent();
    rhs.data_.base.CloneInplace(&data_.base);
    return *this;
  }

  operator InputEvent&() { return data_.base; }
  operator const InputEvent&() const { return data_.base; }

  InputEvent& base() { return data_.base; }
  const InputEvent& base() const { return data_.base; }

  // Categorize an event according to its type.
  //
  // If the event cannot be categorized, it is left uncategorized.
  static AnyInputEvent Categorize(InputEvent uncategorized_ev);

 private:
  union InputEventUnion {
    InputEvent base;
    KeyEvent key_event;
    RelEvent rel_event;
    AbsEvent abs_event;
    SynchEvent synch_event;
    SwitchEvent switch_event;
    MiscEvent misc_event;
    LEDEvent led_event;
    AutorepeatEvent autorepeat_event;
    SoundEvent sound_event;

    ~InputEventUnion() { base.~InputEvent(); }
  } data_;
};

}  // namespace evdevpp

template <>
class fmt::formatter<absl::Time> {
 public:
  auto parse(format_parse_context& ctx) {
    const auto* begin = ctx.begin();
    const auto* end = ctx.end();
    if (begin == end) {
      return begin;
    }
    const auto* end_brace = std::find(begin, end, '}');
    if (end_brace == end) {
      throw fmt::format_error("Invalid format - No matching brace");
    }
    // TODO: This doesn't actually work in a useful way because fmt consumes %
    // characters
    //       There's a way to hijack the parser to keep all the tokens but I'm
    //       being lazy
    format_string_ = std::string(begin, end_brace);
    return end_brace;
  }

  template <typename FmtContext>
  auto format(const absl::Time& t, FmtContext& ctx) const {
    if (format_string_) {
      return fmt::format_to(
          ctx.out(), "{}",
          absl::FormatTime(*format_string_, t, absl::UTCTimeZone()));
    }
    // This implementation allows for printing without allocating memory.
    std::tm t_tm = absl::ToTM(t, absl::UTCTimeZone());
    return fmt::format_to(
        ctx.out(), "{:%FT%T}.{:09d}Z", t_tm,
        absl::ToInt64Nanoseconds(t - absl::FromTM(t_tm, absl::UTCTimeZone())));
  }

 private:
  std::optional<std::string> format_string_ = std::nullopt;
};

template <>
struct fmt::formatter<evdevpp::InputEvent> {
  auto parse(format_parse_context& ctx) {
    const auto* begin = ctx.begin();
    const auto* end = ctx.end();
    if (begin == end) {
      return begin;
    }
    const auto* end_brace = std::find(begin, end, '}');
    if (end_brace == end) {
      throw fmt::format_error("Invalid format - No matching brace");
    }
    return end_brace;
  }

  template <typename FmtContext>
  auto format(const evdevpp::InputEvent& ev, FmtContext& ctx) const {
    auto ctx_out = fmt::format_to(ctx.out(), "{} event at {}, ",
                                  ev.TypeAsString(), ev.timestamp);
    ctx_out =
        fmt::format_to(ctx_out, "{} (0x{:04X}), ", ev.CodeAsString(), ev.code);
    return fmt::format_to(ctx_out, "val {:12d}", ev.value);
  }
};

template <>
struct fmt::formatter<evdevpp::KeyEvent> : fmt::formatter<evdevpp::InputEvent> {
  template <typename FmtContext>
  auto format(const evdevpp::KeyEvent& ev, FmtContext& ctx) const {
    auto ctx_out = fmt::format_to(ctx.out(), "{} event at {}, ",
                                  ev.TypeAsString(), ev.timestamp);
    ctx_out =
        fmt::format_to(ctx_out, "{} (0x{:04X}), ", ev.CodeAsString(), ev.code);
    switch (ev.state) {
      case evdevpp::KeyEvent::State::kUp:
        return fmt::format_to(ctx_out, "{}", "up");
      case evdevpp::KeyEvent::State::kDown:
        return fmt::format_to(ctx_out, "{}", "down");
      case evdevpp::KeyEvent::State::kHold:
        return fmt::format_to(ctx_out, "{}", "hold");
    }
  }
};

#endif  // EVDEVPP_EVDEVPP_EVENTS_H_
